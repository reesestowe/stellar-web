<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Web - Particle Network Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #0a0015;
            color: #fff;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
            background: #0a0015;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(10, 20, 40, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .control-panel.collapsed {
            transform: translateY(-50%) translateX(calc(100% + 20px));
        }

        .panel-header {
            font-size: 18px;
            font-weight: bold;
            color: #00ffff;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            letter-spacing: 2px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #fff;
            font-size: 13px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group .value-display {
            color: #00ffaa;
            font-weight: bold;
            float: right;
            text-shadow: 0 0 5px rgba(0, 255, 170, 0.6);
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(26px);
        }

        .toggle-label {
            color: #fff;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Music Section */
        .music-section {
            margin-top: 10px;
        }

        .section-divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, #ff00ff, transparent);
            margin: 15px 0;
        }

        .section-title {
            color: #ff00ff;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.8);
        }

        .music-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.3), rgba(0, 255, 255, 0.3));
            border: 2px solid #ff00ff;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            letter-spacing: 2px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }

        .music-btn:hover {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.5), rgba(0, 255, 255, 0.5));
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.6);
        }

        .music-btn.playing {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.5), rgba(255, 0, 255, 0.5));
            border-color: #00ffff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        }

        /* Theme Section */
        .theme-section {
            margin-top: 10px;
        }

        .theme-select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 8px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            cursor: pointer;
            outline: none;
            margin-bottom: 15px;
        }

        .theme-select option {
            background: #0a1428;
            color: #fff;
        }

        .color-picker-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .color-picker-label {
            color: #fff;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .color-picker-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: 2px solid #00ffff;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            background: none;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 6px;
        }

        .color-picker::-moz-color-swatch {
            border: none;
            border-radius: 6px;
        }

        /* Collapse Button */
        .collapse-btn {
            position: fixed;
            right: 20px;
            top: 20px;
            background: rgba(10, 20, 40, 0.95);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 1001;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            transition: all 0.3s ease;
        }

        .collapse-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        }

        /* Statistics Panel */
        .stats-panel {
            position: fixed;
            left: 20px;
            top: 20px;
            background: rgba(10, 20, 40, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #00ff41;
            border-radius: 10px;
            padding: 15px;
            min-width: 220px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .stats-title {
            font-size: 14px;
            font-weight: bold;
            color: #00ff41;
            margin-bottom: 12px;
            text-align: center;
            letter-spacing: 2px;
            text-shadow: 0 0 8px rgba(0, 255, 65, 0.8);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #00ffaa;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 170, 0.6);
        }

        /* Scrollbar styling */
        .control-panel::-webkit-scrollbar {
            width: 8px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.5);
            border-radius: 5px;
        }

        .control-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <canvas id="network"></canvas>

    <button class="collapse-btn" id="collapseBtn">Hide Controls</button>

    <!-- Statistics Panel -->
    <div class="stats-panel">
        <div class="stats-title">NETWORK STATS</div>
        <div class="stat-row">
            <span class="stat-label">Nodes:</span>
            <span class="stat-value" id="stat-nodes">100</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Edges:</span>
            <span class="stat-value" id="stat-edges">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Avg Connections:</span>
            <span class="stat-value" id="stat-avg">0.0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Density:</span>
            <span class="stat-value" id="stat-density">0.0%</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">FPS:</span>
            <span class="stat-value" id="stat-fps">60</span>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel" id="controlPanel">
        <div class="panel-header">âš™ NETWORK CONTROLS</div>

        <div class="control-group">
            <label>
                Node Count
                <span class="value-display" id="nodeCountValue">100</span>
            </label>
            <input type="range" id="nodeCount" min="50" max="300" value="100" step="10">
        </div>

        <div class="control-group">
            <label>
                Node Speed
                <span class="value-display" id="nodeSpeedValue">1.0</span>
            </label>
            <input type="range" id="nodeSpeed" min="0.1" max="5" value="1" step="0.1">
        </div>

        <div class="control-group">
            <label>
                Node Size
                <span class="value-display" id="nodeSizeValue">3</span>
            </label>
            <input type="range" id="nodeSize" min="1" max="10" value="3" step="0.5">
        </div>

        <div class="control-group">
            <label>
                Connectivity Radius
                <span class="value-display" id="connectivityValue">120</span>
            </label>
            <input type="range" id="connectivity" min="50" max="300" value="120" step="10">
        </div>

        <div class="control-group">
            <label>
                Edge Thickness
                <span class="value-display" id="edgeThicknessValue">1.5</span>
            </label>
            <input type="range" id="edgeThickness" min="0.5" max="5" value="1.5" step="0.1">
        </div>

        <div class="control-group">
            <label>
                Edge Opacity
                <span class="value-display" id="edgeOpacityValue">0.5</span>
            </label>
            <input type="range" id="edgeOpacity" min="0.1" max="1" value="0.5" step="0.05">
        </div>

        <div class="control-group">
            <label>
                Pulse Speed
                <span class="value-display" id="pulseSpeedValue">1.0</span>
            </label>
            <input type="range" id="pulseSpeed" min="0" max="5" value="1" step="0.1">
        </div>

        <div class="control-group">
            <label>
                Depth Effect
                <span class="value-display" id="depthEffectValue">1.5</span>
            </label>
            <input type="range" id="depthEffect" min="0" max="3" value="1.5" step="0.1">
        </div>

        <div class="toggle-container">
            <span class="toggle-label">Mouse Interaction</span>
            <div class="toggle-switch" id="mouseToggle">
                <div class="toggle-slider"></div>
            </div>
        </div>

        <div class="toggle-container">
            <span class="toggle-label">Attraction Mode</span>
            <div class="toggle-switch" id="attractionToggle">
                <div class="toggle-slider"></div>
            </div>
        </div>

        <div class="toggle-container">
            <span class="toggle-label">Beat Reactive</span>
            <div class="toggle-switch" id="beatToggle">
                <div class="toggle-slider"></div>
            </div>
        </div>

        <div class="music-section">
            <div class="section-divider"></div>
            <div class="section-title">â™ª HOUSE MUSIC</div>

            <button class="music-btn" id="musicBtn">â–¶ PLAY</button>

            <div class="control-group">
                <label>
                    BPM
                    <span class="value-display" id="bpmValue">128</span>
                </label>
                <input type="range" id="bpm" min="100" max="160" value="128" step="1">
            </div>

            <div class="control-group">
                <label>
                    Volume
                    <span class="value-display" id="volumeValue">0.5</span>
                </label>
                <input type="range" id="volume" min="0" max="1" value="0.5" step="0.05">
            </div>
        </div>

        <div class="theme-section">
            <div class="section-divider"></div>
            <div class="section-title">ðŸŽ¨ COLOR THEMES</div>

            <select class="theme-select" id="themeSelect">
                <option value="cyber">Cyber (Default)</option>
                <option value="sunset">Sunset</option>
                <option value="ocean">Ocean</option>
                <option value="forest">Forest</option>
                <option value="neonPink">Neon Pink</option>
                <option value="galaxy">Galaxy</option>
                <option value="fire">Fire</option>
                <option value="ice">Ice</option>
                <option value="custom">Custom</option>
            </select>

            <div class="color-picker-group">
                <span class="color-picker-label">Background</span>
                <input type="color" class="color-picker" id="bgColor" value="#0a0015">
            </div>

            <div class="color-picker-group">
                <span class="color-picker-label">Node Color 1</span>
                <input type="color" class="color-picker" id="nodeColor1" value="#00ffff">
            </div>

            <div class="color-picker-group">
                <span class="color-picker-label">Node Color 2</span>
                <input type="color" class="color-picker" id="nodeColor2" value="#ff00ff">
            </div>

            <div class="color-picker-group">
                <span class="color-picker-label">Edge Color 1</span>
                <input type="color" class="color-picker" id="edgeColor1" value="#00ffff">
            </div>

            <div class="color-picker-group">
                <span class="color-picker-label">Edge Color 2</span>
                <input type="color" class="color-picker" id="edgeColor2" value="#8000ff">
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('network');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Configuration
        const config = {
            nodeCount: 100,
            nodeSpeed: 1.0,
            nodeSize: 3,
            connectivityRadius: 120,
            edgeThickness: 1.5,
            edgeOpacity: 0.5,
            pulseSpeed: 1.0,
            depthEffect: 1.5,
            mouseInteraction: false,
            attractionMode: false,
            beatReactive: false
        };

        // Color theme configuration
        const colorConfig = {
            background: '#0a0015',
            nodeColor1: '#00ffff',
            nodeColor2: '#ff00ff',
            edgeColor1: '#00ffff',
            edgeColor2: '#8000ff'
        };

        // Preset themes
        const themes = {
            cyber: {
                background: '#0a0015',
                nodeColor1: '#00ffff',
                nodeColor2: '#ff00ff',
                edgeColor1: '#00ffff',
                edgeColor2: '#8000ff'
            },
            sunset: {
                background: '#1a0a1e',
                nodeColor1: '#ff6b35',
                nodeColor2: '#f7c59f',
                edgeColor1: '#ff6b35',
                edgeColor2: '#ffcc00'
            },
            ocean: {
                background: '#001219',
                nodeColor1: '#0077b6',
                nodeColor2: '#00b4d8',
                edgeColor1: '#48cae4',
                edgeColor2: '#90e0ef'
            },
            forest: {
                background: '#0d1f0d',
                nodeColor1: '#2d6a4f',
                nodeColor2: '#95d5b2',
                edgeColor1: '#40916c',
                edgeColor2: '#74c69d'
            },
            neonPink: {
                background: '#0f0014',
                nodeColor1: '#ff00ff',
                nodeColor2: '#ff69b4',
                edgeColor1: '#ff1493',
                edgeColor2: '#ff69b4'
            },
            galaxy: {
                background: '#0b0014',
                nodeColor1: '#9d4edd',
                nodeColor2: '#e0aaff',
                edgeColor1: '#7b2cbf',
                edgeColor2: '#c77dff'
            },
            fire: {
                background: '#1a0500',
                nodeColor1: '#ff4500',
                nodeColor2: '#ffd700',
                edgeColor1: '#ff6347',
                edgeColor2: '#ff8c00'
            },
            ice: {
                background: '#001020',
                nodeColor1: '#a5f3fc',
                nodeColor2: '#ffffff',
                edgeColor1: '#67e8f9',
                edgeColor2: '#e0f2fe'
            }
        };

        // Mouse tracking
        let mouse = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 200
        };

        // Audio context for beat detection
        let audioContext = null;
        let analyser = null;
        let audioSource = null;
        let audioData = null;
        let beatIntensity = 0;

        // House music generator state
        let musicPlaying = false;
        let musicBPM = 128;
        let musicVolume = 0.5;
        let nextNoteTime = 0;
        let currentStep = 0;
        let schedulerTimer = null;
        let masterGain = null;

        // Explosion particles
        let explosionParticles = [];

        // FPS tracking
        let fps = 0;
        let lastTime = performance.now();
        let frameCount = 0;

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 255, b: 255 };
        }

        // Interpolate between two colors
        function lerpColor(color1, color2, t) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            return {
                r: Math.round(c1.r + (c2.r - c1.r) * t),
                g: Math.round(c1.g + (c2.g - c1.g) * t),
                b: Math.round(c1.b + (c2.b - c1.b) * t)
            };
        }

        // Node class
        class Node {
            constructor() {
                this.reset();
                this.pulsePhase = Math.random() * Math.PI * 2;
            }

            reset() {
                // 3D position
                this.x = Math.random() * canvas.width - canvas.width / 2;
                this.y = Math.random() * canvas.height - canvas.height / 2;
                this.z = Math.random() * 1000 - 500;

                // Velocity
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.vz = (Math.random() - 0.5) * 2;

                // Color blend factor (0 = color1, 1 = color2)
                this.colorBlend = Math.random();
            }

            update() {
                // Apply velocity with speed multiplier
                this.x += this.vx * config.nodeSpeed;
                this.y += this.vy * config.nodeSpeed;
                this.z += this.vz * config.nodeSpeed;

                // Mouse interaction
                if (config.mouseInteraction) {
                    const screenPos = this.getScreenPosition();
                    const dx = screenPos.x - mouse.x;
                    const dy = screenPos.y - mouse.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < mouse.radius) {
                        const force = (1 - distance / mouse.radius) * 0.5;
                        const angle = Math.atan2(dy, dx);
                        const direction = config.attractionMode ? -1 : 1;

                        this.vx += Math.cos(angle) * force * direction;
                        this.vy += Math.sin(angle) * force * direction;
                    }
                }

                // Damping
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.vz *= 0.98;

                // Keep minimum velocity
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy + this.vz * this.vz);
                if (speed < 0.5) {
                    this.vx += (Math.random() - 0.5) * 0.1;
                    this.vy += (Math.random() - 0.5) * 0.1;
                    this.vz += (Math.random() - 0.5) * 0.1;
                }

                // Wrap around boundaries
                const halfWidth = canvas.width / 2;
                const halfHeight = canvas.height / 2;

                if (this.x < -halfWidth) this.x = halfWidth;
                if (this.x > halfWidth) this.x = -halfWidth;
                if (this.y < -halfHeight) this.y = halfHeight;
                if (this.y > halfHeight) this.y = -halfHeight;
                if (this.z < -500) this.z = 500;
                if (this.z > 500) this.z = -500;

                // Update pulse phase
                this.pulsePhase += 0.05 * config.pulseSpeed;
            }

            getScreenPosition() {
                // 3D to 2D perspective projection
                const perspective = 500;
                const scale = perspective / (perspective + this.z);
                const screenX = (this.x * scale) + canvas.width / 2;
                const screenY = (this.y * scale) + canvas.height / 2;

                return { x: screenX, y: screenY, scale: scale };
            }

            getDepthFactor() {
                // Calculate depth factor (0 = far, 1 = close)
                return (this.z + 500) / 1000;
            }

            draw() {
                const pos = this.getScreenPosition();
                const depthFactor = this.getDepthFactor();

                // Calculate size based on depth
                const baseSize = config.nodeSize * pos.scale;
                const depthSize = baseSize * (0.5 + depthFactor * 0.5 * config.depthEffect);

                // Pulsing effect
                const pulse = Math.sin(this.pulsePhase) * 0.3 + 1;
                const size = depthSize * pulse;

                // Opacity based on depth
                const opacity = 0.3 + depthFactor * 0.7;

                // Get interpolated color from theme
                const color = lerpColor(colorConfig.nodeColor1, colorConfig.nodeColor2, this.colorBlend);

                // Draw node (removed expensive glow for performance)
                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Optional: Simple glow for larger nodes only
                if (size > 2) {
                    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Explosion Particle class
        class ExplosionParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 15;
                this.vy = (Math.random() - 0.5) * 15;
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.01;
                this.size = Math.random() * 4 + 2;
                this.colorBlend = Math.random();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= this.decay;
            }

            draw() {
                const alpha = this.life;
                const color = lerpColor(colorConfig.nodeColor1, colorConfig.nodeColor2, this.colorBlend);

                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();

                // Glow
                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Initialize nodes
        let nodes = [];

        function initNodes() {
            nodes = [];
            for (let i = 0; i < config.nodeCount; i++) {
                nodes.push(new Node());
            }
        }

        // Create explosion at position
        function createExplosion(x, y, count = 30) {
            for (let i = 0; i < count; i++) {
                explosionParticles.push(new ExplosionParticle(x, y));
            }
        }

        // Initialize audio for beat detection
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                audioData = new Uint8Array(analyser.frequencyBinCount);

                // Create master gain for volume control
                masterGain = audioContext.createGain();
                masterGain.gain.value = musicVolume;
                masterGain.connect(analyser);
                analyser.connect(audioContext.destination);
            }
        }

        // House Music Generator
        // =====================

        // Create a kick drum sound
        function playKick(time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);

            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

            osc.connect(gain);
            gain.connect(masterGain);

            osc.start(time);
            osc.stop(time + 0.3);
        }

        // Create a hi-hat sound using noise
        function playHiHat(time, open = false) {
            const bufferSize = audioContext.sampleRate * 0.05;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Fill with noise
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;

            // High-pass filter for hi-hat character
            const highpass = audioContext.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.value = 7000;

            const gain = audioContext.createGain();
            const duration = open ? 0.15 : 0.05;
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + duration);

            noise.connect(highpass);
            highpass.connect(gain);
            gain.connect(masterGain);

            noise.start(time);
            noise.stop(time + duration);
        }

        // Create a snare/clap sound
        function playSnare(time) {
            // Noise component
            const bufferSize = audioContext.sampleRate * 0.15;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;

            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 3000;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(0.5, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(masterGain);

            noise.start(time);
            noise.stop(time + 0.15);

            // Tonal component
            const osc = audioContext.createOscillator();
            const oscGain = audioContext.createGain();

            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, time);
            osc.frequency.exponentialRampToValueAtTime(100, time + 0.05);

            oscGain.gain.setValueAtTime(0.3, time);
            oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

            osc.connect(oscGain);
            oscGain.connect(masterGain);

            osc.start(time);
            osc.stop(time + 0.1);
        }

        // Create bass note
        function playBass(time, note) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.type = 'sawtooth';
            osc.frequency.value = note;

            // Low-pass filter for warmer bass
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400, time);
            filter.frequency.exponentialRampToValueAtTime(200, time + 0.1);

            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);

            osc.start(time);
            osc.stop(time + 0.2);
        }

        // Create synth chord stab
        function playSynth(time, notes) {
            notes.forEach((note, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'square';
                osc.frequency.value = note;

                // Filter for smoother sound
                const filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                filter.Q.value = 5;

                gain.gain.setValueAtTime(0.08, time);
                gain.gain.setValueAtTime(0.08, time + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);

                osc.start(time);
                osc.stop(time + 0.4);
            });
        }

        // Bass notes for the pattern (E minor pentatonic low octave)
        const bassNotes = [82.41, 98, 110, 123.47, 82.41, 98, 110, 82.41]; // E2, G2, A2, B2

        // Chord progression (E minor house)
        const chords = [
            [164.81, 196, 246.94],  // Em (E3, G3, B3)
            [146.83, 174.61, 220],  // D (D3, F#3, A3)
            [130.81, 164.81, 196],  // C (C3, E3, G3)
            [146.83, 174.61, 220]   // D (D3, F#3, A3)
        ];

        // Schedule the next notes
        function scheduleNote(stepTime, step) {
            const sixteenthNote = (60 / musicBPM) / 4;

            // Kick on 1, 5, 9, 13 (4-on-the-floor)
            if (step % 4 === 0) {
                playKick(stepTime);
            }

            // Hi-hat on every 8th note, open on off-beats
            if (step % 2 === 0) {
                playHiHat(stepTime, step % 4 === 2);
            }

            // Snare/clap on 5 and 13 (beats 2 and 4)
            if (step === 4 || step === 12) {
                playSnare(stepTime);
            }

            // Bass on 1, 3, 7, 9, 11, 15
            if (step === 0 || step === 2 || step === 6 || step === 8 || step === 10 || step === 14) {
                const bassIndex = Math.floor(step / 2) % bassNotes.length;
                playBass(stepTime, bassNotes[bassIndex]);
            }

            // Chord stabs on beat 1 of every 2 bars (step 0 every 32 steps, but we use 16)
            if (step === 0) {
                const chordIndex = Math.floor(Math.random() * chords.length);
                playSynth(stepTime, chords[chordIndex]);
            }
        }

        // Main scheduler loop
        function scheduler() {
            const sixteenthNote = (60 / musicBPM) / 4;

            // Schedule notes ahead of time for accuracy
            while (nextNoteTime < audioContext.currentTime + 0.1) {
                scheduleNote(nextNoteTime, currentStep);
                nextNoteTime += sixteenthNote;
                currentStep = (currentStep + 1) % 16;
            }
        }

        // Start the music
        function startMusic() {
            initAudio();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Enable beat reactive when music starts
            config.beatReactive = true;
            document.getElementById('beatToggle').classList.add('active');

            musicPlaying = true;
            currentStep = 0;
            nextNoteTime = audioContext.currentTime;

            // Schedule notes using setInterval
            schedulerTimer = setInterval(scheduler, 25);

            // Update button
            document.getElementById('musicBtn').textContent = 'â¸ PAUSE';
            document.getElementById('musicBtn').classList.add('playing');
        }

        // Stop the music
        function stopMusic() {
            musicPlaying = false;

            if (schedulerTimer) {
                clearInterval(schedulerTimer);
                schedulerTimer = null;
            }

            // Update button
            document.getElementById('musicBtn').textContent = 'â–¶ PLAY';
            document.getElementById('musicBtn').classList.remove('playing');
        }

        // Toggle music
        function toggleMusic() {
            if (musicPlaying) {
                stopMusic();
            } else {
                startMusic();
            }
        }

        // Start listening to microphone
        async function startMicrophone() {
            try {
                initAudio();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioSource = audioContext.createMediaStreamSource(stream);
                audioSource.connect(analyser);
                config.beatReactive = true;
            } catch (err) {
                console.log('Microphone access denied');
            }
        }

        // Analyze audio for beat
        function analyzeBeat() {
            if (!analyser || !config.beatReactive) {
                beatIntensity *= 0.95;
                return;
            }

            analyser.getByteFrequencyData(audioData);

            // Get bass frequencies (lower range)
            let bassSum = 0;
            for (let i = 0; i < 10; i++) {
                bassSum += audioData[i];
            }
            const bassAvg = bassSum / 10 / 255;

            // Smooth the beat intensity
            beatIntensity = beatIntensity * 0.7 + bassAvg * 0.3;
        }

        // Draw edge between two nodes
        function drawEdge(nodeA, nodeB, distance) {
            const posA = nodeA.getScreenPosition();
            const posB = nodeB.getScreenPosition();

            // Calculate opacity based on distance
            const distanceFactor = 1 - (distance / config.connectivityRadius);
            let opacity = config.edgeOpacity * distanceFactor;

            // Calculate thickness based on distance
            let thickness = config.edgeThickness * distanceFactor;

            // Beat reactive edge boost
            if (config.beatReactive && beatIntensity > 0.6) {
                opacity *= (1 + beatIntensity);
                thickness *= (1 + beatIntensity * 0.5);
            }

            // Color gradient based on distance using theme colors
            const t = distance / config.connectivityRadius;
            const color = lerpColor(colorConfig.edgeColor1, colorConfig.edgeColor2, t);

            // Draw line
            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity})`;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.moveTo(posA.x, posA.y);
            ctx.lineTo(posB.x, posB.y);
            ctx.stroke();
        }

        // Calculate and draw all connections (optimized)
        function drawConnections() {
            let edgeCount = 0;
            const maxConnections = 5; // Limit connections per node for performance

            for (let i = 0; i < nodes.length; i++) {
                let connections = 0;

                for (let j = i + 1; j < nodes.length && connections < maxConnections; j++) {
                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const dz = nodes[i].z - nodes[j].z;

                    // Quick distance check without sqrt first
                    const distSquared = dx * dx + dy * dy + dz * dz;
                    const radiusSquared = config.connectivityRadius * config.connectivityRadius;

                    if (distSquared < radiusSquared) {
                        const distance = Math.sqrt(distSquared);
                        drawEdge(nodes[i], nodes[j], distance);
                        edgeCount++;
                        connections++;
                    }
                }
            }

            return edgeCount;
        }

        // Animation loop
        function animate() {
            // Analyze audio for beat
            analyzeBeat();

            // Clear canvas with theme background color
            ctx.fillStyle = colorConfig.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Beat reactive background flash using theme node color
            if (beatIntensity > 0.5) {
                const flashColor = hexToRgb(colorConfig.nodeColor1);
                ctx.fillStyle = `rgba(${flashColor.r}, ${flashColor.g}, ${flashColor.b}, ${(beatIntensity - 0.5) * 0.1})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Update all nodes
            nodes.forEach(node => {
                node.update();

                // Beat reactive pulse
                if (config.beatReactive && beatIntensity > 0.6) {
                    node.pulsePhase += beatIntensity * 0.5;
                }
            });

            // Draw connections (edges)
            const edgeCount = drawConnections();

            // Draw nodes (with beat reactive size boost)
            nodes.forEach(node => node.draw());

            // Update and draw explosion particles
            explosionParticles.forEach(particle => particle.update());
            explosionParticles = explosionParticles.filter(p => !p.isDead());
            explosionParticles.forEach(particle => particle.draw());

            // Update statistics
            updateStats(edgeCount);

            // Calculate FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }

            requestAnimationFrame(animate);
        }

        // Update statistics panel
        function updateStats(edgeCount) {
            document.getElementById('stat-nodes').textContent = config.nodeCount;
            document.getElementById('stat-edges').textContent = edgeCount;

            const avgConnections = config.nodeCount > 0 ? (edgeCount * 2 / config.nodeCount).toFixed(1) : 0;
            document.getElementById('stat-avg').textContent = avgConnections;

            const maxPossibleEdges = (config.nodeCount * (config.nodeCount - 1)) / 2;
            const density = maxPossibleEdges > 0 ? ((edgeCount / maxPossibleEdges) * 100).toFixed(1) : 0;
            document.getElementById('stat-density').textContent = density + '%';

            document.getElementById('stat-fps').textContent = fps;
        }

        // Control handlers
        document.getElementById('nodeCount').addEventListener('input', (e) => {
            config.nodeCount = parseInt(e.target.value);
            document.getElementById('nodeCountValue').textContent = config.nodeCount;
            initNodes();
        });

        document.getElementById('nodeSpeed').addEventListener('input', (e) => {
            config.nodeSpeed = parseFloat(e.target.value);
            document.getElementById('nodeSpeedValue').textContent = config.nodeSpeed.toFixed(1);
        });

        document.getElementById('nodeSize').addEventListener('input', (e) => {
            config.nodeSize = parseFloat(e.target.value);
            document.getElementById('nodeSizeValue').textContent = config.nodeSize;
        });

        document.getElementById('connectivity').addEventListener('input', (e) => {
            config.connectivityRadius = parseInt(e.target.value);
            document.getElementById('connectivityValue').textContent = config.connectivityRadius;
        });

        document.getElementById('edgeThickness').addEventListener('input', (e) => {
            config.edgeThickness = parseFloat(e.target.value);
            document.getElementById('edgeThicknessValue').textContent = config.edgeThickness.toFixed(1);
        });

        document.getElementById('edgeOpacity').addEventListener('input', (e) => {
            config.edgeOpacity = parseFloat(e.target.value);
            document.getElementById('edgeOpacityValue').textContent = config.edgeOpacity.toFixed(2);
        });

        document.getElementById('pulseSpeed').addEventListener('input', (e) => {
            config.pulseSpeed = parseFloat(e.target.value);
            document.getElementById('pulseSpeedValue').textContent = config.pulseSpeed.toFixed(1);
        });

        document.getElementById('depthEffect').addEventListener('input', (e) => {
            config.depthEffect = parseFloat(e.target.value);
            document.getElementById('depthEffectValue').textContent = config.depthEffect.toFixed(1);
        });

        // Toggle handlers
        document.getElementById('mouseToggle').addEventListener('click', (e) => {
            config.mouseInteraction = !config.mouseInteraction;
            e.currentTarget.classList.toggle('active');
        });

        document.getElementById('attractionToggle').addEventListener('click', (e) => {
            config.attractionMode = !config.attractionMode;
            e.currentTarget.classList.toggle('active');
        });

        // Collapse button handler
        document.getElementById('collapseBtn').addEventListener('click', () => {
            const panel = document.getElementById('controlPanel');
            const btn = document.getElementById('collapseBtn');
            panel.classList.toggle('collapsed');
            btn.textContent = panel.classList.contains('collapsed') ? 'Show Controls' : 'Hide Controls';
        });

        // Beat reactive toggle
        document.getElementById('beatToggle').addEventListener('click', async (e) => {
            if (!config.beatReactive) {
                await startMicrophone();
                e.currentTarget.classList.add('active');
            } else {
                config.beatReactive = false;
                e.currentTarget.classList.remove('active');
            }
        });

        // Music controls
        document.getElementById('musicBtn').addEventListener('click', toggleMusic);

        document.getElementById('bpm').addEventListener('input', (e) => {
            musicBPM = parseInt(e.target.value);
            document.getElementById('bpmValue').textContent = musicBPM;
        });

        document.getElementById('volume').addEventListener('input', (e) => {
            musicVolume = parseFloat(e.target.value);
            document.getElementById('volumeValue').textContent = musicVolume.toFixed(2);
            if (masterGain) {
                masterGain.gain.value = musicVolume;
            }
        });

        // Theme controls
        function updateStatsPanel() {
            const statsPanel = document.querySelector('.stats-panel');
            const statsTitle = document.querySelector('.stats-title');
            const statValues = document.querySelectorAll('.stat-value');

            // Update border and shadow to match nodeColor1
            statsPanel.style.borderColor = colorConfig.nodeColor1;
            statsPanel.style.boxShadow = `0 0 20px ${colorConfig.nodeColor1}40`;

            // Update title color
            statsTitle.style.color = colorConfig.nodeColor1;
            statsTitle.style.textShadow = `0 0 8px ${colorConfig.nodeColor1}cc`;

            // Update stat values to match nodeColor2
            statValues.forEach(val => {
                val.style.color = colorConfig.nodeColor2;
                val.style.textShadow = `0 0 5px ${colorConfig.nodeColor2}99`;
            });
        }

        function applyTheme(themeName) {
            if (themes[themeName]) {
                const theme = themes[themeName];
                colorConfig.background = theme.background;
                colorConfig.nodeColor1 = theme.nodeColor1;
                colorConfig.nodeColor2 = theme.nodeColor2;
                colorConfig.edgeColor1 = theme.edgeColor1;
                colorConfig.edgeColor2 = theme.edgeColor2;

                // Update color pickers to reflect theme
                document.getElementById('bgColor').value = theme.background;
                document.getElementById('nodeColor1').value = theme.nodeColor1;
                document.getElementById('nodeColor2').value = theme.nodeColor2;
                document.getElementById('edgeColor1').value = theme.edgeColor1;
                document.getElementById('edgeColor2').value = theme.edgeColor2;

                // Update canvas and body background
                canvas.style.background = theme.background;
                document.body.style.background = theme.background;

                // Update stats panel to match theme
                updateStatsPanel();
            }
        }

        document.getElementById('themeSelect').addEventListener('change', (e) => {
            const themeName = e.target.value;
            if (themeName !== 'custom') {
                applyTheme(themeName);
            }
        });

        // Color picker handlers
        document.getElementById('bgColor').addEventListener('input', (e) => {
            colorConfig.background = e.target.value;
            canvas.style.background = e.target.value;
            document.body.style.background = e.target.value;
            document.getElementById('themeSelect').value = 'custom';
        });

        document.getElementById('nodeColor1').addEventListener('input', (e) => {
            colorConfig.nodeColor1 = e.target.value;
            document.getElementById('themeSelect').value = 'custom';
            updateStatsPanel();
        });

        document.getElementById('nodeColor2').addEventListener('input', (e) => {
            colorConfig.nodeColor2 = e.target.value;
            document.getElementById('themeSelect').value = 'custom';
            updateStatsPanel();
        });

        document.getElementById('edgeColor1').addEventListener('input', (e) => {
            colorConfig.edgeColor1 = e.target.value;
            document.getElementById('themeSelect').value = 'custom';
        });

        document.getElementById('edgeColor2').addEventListener('input', (e) => {
            colorConfig.edgeColor2 = e.target.value;
            document.getElementById('themeSelect').value = 'custom';
        });

        // Click handler for explosions
        canvas.addEventListener('click', (e) => {
            createExplosion(e.clientX, e.clientY, 40);
        });

        // Mouse tracking
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            createExplosion(touch.clientX, touch.clientY, 40);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Initialize and start
        initNodes();
        animate();
    </script>
</body>
</html>
